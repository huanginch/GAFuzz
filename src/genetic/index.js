import Select from '../Selection/index.js'
import TS from '../MBA-TS/index.js';
import strMutator from '../Mutation/strMutator.js';

/**
 * Genetic algorithm with Thompson Sampling for mutation
 */
class Genetic {
    constructor(options) {
        this.stats = {};
        this.prevPop = [];
        this.population = [];
        this.options = { ...this.getDefaultOptions(), ...options };
        this.numMutations = strMutator.length;
        this.ts = new TS(); //use thompson sampling to select mutation method
        this.ts.initialize(this.numMutations);
        this.selectedArmRecorder = [];
        this.mutatedIndex = []; //record mutated index
    }

    getDefaultOptions() {
        return {
            populationSize: 250,
            mutateProbability: 0.2,
            crossoverProbability: 0.9,
            fittestNSurvives: 1,
            select1: Select.Fittest,
            select2: Select.Tournament2,
            optimize: (phenotypeA, phenotypeB) =>
                phenotypeA.fitness >= phenotypeB.fitness,
        };
    }

    /**
     * Try cross a pair or one selected phenotypes
     */
    tryCrossover = async () => {
        const { crossoverProbablity, crossoverFunction } = this.options;
        let selected = crossoverFunction && Math.random() <= crossoverProbablity ? this.selectPair() : this.selectOne();
        if (selected.length > 1) {
            selected = await crossoverFunction(selected[0], selected[1]);
        }
        for (let i = 0; i < selected.length; i++) {
            const selectedArm = this.ts.selectArm(); //select mutation method
            this.selectedArmRecorder.push(selectedArm);
            selected[i] = await this.tryMutate(selected[i], selectedArm);
        }
        return selected;
    };

    /**
     * Try mutate entity with optional probabilty
     */
    tryMutate = async (entity, selectedArm) => {
        // applies mutation based on mutation probability
        if (this.options.mutationFunction && Math.random() <= this.options.mutateProbablity) {
            return this.options.mutationFunction(selectedArm, entity);
        }

        return entity;
    };

    /**
     * Startup population, if not passed than will be random generated by randomFunction()
     */
    async seed(entities = []) {
        this.population = entities.map((entity) => ({ fitness: null, entity, state: {} }));
        // seed the population
        // await this.fill(this.population);
    }
    best(count = 1) {
        return this.population.slice(0, count);
    }
    /**
     * Breed population with optional breed settings
     */
    async breed() {
        // crossover and mutate
        let newPop = [];

        // lets the best solution fall through
        if (this.options.fittestNSurvives) {
            const cutted = this.cutPopulation(this.options.fittestNSurvives);

            for (const item of cutted) {
                const tempItem = JSON.parse(JSON.stringify(item));
                newPop.push({ ...tempItem });
            }
        }
        // Lenght may be change dynamically, because fittest and some pairs from crossover
        while (newPop.length < this.options.populationSize) {
            const crossed = await this.tryCrossover();
            newPop.push(...crossed.map((entity) => ({ fitness: null, entity, state: {} })));
        }

        // remove extra entities
        if (newPop.length > this.options.populationSize) {
            newPop.pop();
        }

        //update mutation index
        this.mutatedIndex = newPop.map((individual, index) => {
            // 對每個個體的 entity 的最後一個元素檢查是否為字串型別
            return typeof individual.entity[individual.entity.length - 1] === 'string' ? index : undefined;
        }).filter(index => index !== undefined); // 過濾出不為 undefined 的索引
        // console.log('mutatedIndex', this.mutatedIndex);

        // deduplicate population
        if (this.options.deduplicate) {
            newPop = newPop.filter((ph) => this.options.deduplicate(ph.entity));
        }
        await this.fill(newPop);
        // console.log('newPop', newPop);
        this.prevPop = JSON.parse(JSON.stringify(this.population));
        this.population = newPop;
    }
    /**
     * Estimate population before breeding
     */
    async estimate() {
        const { fitnessFunction } = this.options;
        // reset for each generation
        let i = 0;
        for await (const target of this.population) {
            if (i <= this.options.fittestNSurvives - 1 && target.fitness !== null) {
                //the fittestNSurvives are already estimated
                // if it is the fittestNSurvives, then skip
                i++;
                continue;
            }

            // estimate fitness
            const { fitness, state } = await fitnessFunction(target.entity);
            target.fitness = fitness;
            target.state = state;
            i++;
        }
        // 有做突變的個體才更新 thompson sampling
        if(this.mutatedIndex.length > 0) {
            this.updateTS();
        }
    }

    countSuccess() {
        let numSuccess = [0, 0, 0, 0];
        let numFailures = [0, 0, 0, 0];
        this.mutatedIndex.forEach((index) => {
            //if prevPop's fitness is smaller than current fitness, then success
            if (this.stats.meanWithoutElite < this.population[index].fitness) {
                numSuccess[this.selectedArmRecorder[index]]++;
            } else {
                numFailures[this.selectedArmRecorder[index]]++;
            }
        });

        return { numSuccess, numFailures };
    }

    updateTS() {
        const {numSuccess, numFailures} = this.countSuccess();
        for (let i = 0; i < this.numMutations; i++) {
            let success = numSuccess[i] > numFailures[i] ? true : false;
            this.ts.updateArm(i, success);
        }
        this.mutatedIndex = [];
    }

    /**
     * Appli population sorting
     */
    reorderPopulation() {
        this.population = this.population.sort((a, b) => (this.options.optimize(a, b) ? -1 : 1));
    }
    /** Fill population if is not full */
    async fill(arr) {
        while (arr.length < this.options.populationSize) {
            const entity = await this.options.randomFunction();
            arr.push({ entity, fitness: null, state: {} });
        }
    }
    /**
     * Mean deviation
     */
    getMean() {
        return this.population.reduce((a, b) => a + b.fitness, 0) / this.population.length;
    }
    /**
     * Mean without elite (fitness of the best entity in population) 
     */
    getMeanWithoutElite() {
        return this.population.slice(this.options.fittestNSurvives).reduce((a, b) => a + b.fitness, 0) / (this.population.length - this.options.fittestNSurvives);
    }
    /**
     * Standart deviation
     */
    getStdev(mean) {
        const { population: pop } = this;
        const l = pop.length;
        return Math.sqrt(pop.map(({ fitness }) => (fitness - mean) * (fitness - mean)).reduce((a, b) => a + b, 0) / l);
    }
    /**
     * Select one phenotype from population
     */
    selectOne() {
        const { select1 } = this.options;
        return [select1.call(this, this.population)];
    }
    /**
     * Select two phenotypes from population for crossover
     */
    selectPair() {
        const { select2 } = this.options;
        return [select2.call(this, this.population), select2.call(this, this.population)];
    }
    /**
     * Return population without an estimate (fitness)
     */
    cutPopulation(count) {
        return this.population.slice(0, count).map((ph) => ({ fitness: ph.fitness, entity: ph.entity, state: ph.state }));
    }
}
export default Genetic;
