'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const appendFileSync = require('fs').appendFileSync;

const Select = {
    Fittest: Fittest$1,
    FittestLinear: FittestLinear$1,
    FittestRandom: FittestRandom$1,
    Random: Random$1,
    RandomLinearRank: RandomLinearRank$1,
    Sequential: Sequential$1,
    Tournament2,
    Tournament3,
    RouletteWheel,
    Rank,
};
class Genetic {
    constructor(options) {
        this.stats = {};
        this.population = [];
        this.internalGenState = {}; /* Used for random linear */
        /**
         * Try cross a pair or one selected phenotypes
         */
        this.tryCrossover = async () => {
            const { crossoverProbablity, crossoverFunction } = this.options;
            let selected = crossoverFunction && Math.random() <= crossoverProbablity ? this.selectPair() : this.selectOne();
            if (selected.length > 1) {
                selected = await crossoverFunction(selected[0], selected[1]);
            }
            for (let i = 0; i < selected.length; i++) {
                selected[i] = await this.tryMutate(selected[i]);
            }
            return selected;
        };
        /**
         * Try mutate entity with optional probabilty
         */
        this.tryMutate = async (entity) => {
            // applies mutation based on mutation probability
            if (this.options.mutationFunction && Math.random() <= this.options.mutateProbablity) {
                return this.options.mutationFunction(entity);
            }
            return entity;
        };
        const defaultOptions = {
            populationSize: 250,
            mutateProbablity: 0.2,
            crossoverProbablity: 0.9,
            fittestNSurvives: 1,
            select1: Select.Fittest,
            select2: Select.Tournament2,
            optimize: (phenotypeA, phenotypeB) => {
                return phenotypeA.fitness >= phenotypeB.fitness;
            },
        };
        this.options = { ...defaultOptions, ...options };
    }
    /**
     * Startup population, if not passed than will be random generated by randomFunction()
     */
    async seed(entities = []) {
        this.population = entities.map((entity) => ({ fitness: null, entity, state: {} }));
        // seed the population
        await this.fill(this.population);
    }
    best(count = 1) {
        return this.population.slice(0, count);
    }
    /**
     * Breed population with optional breed settings
     */
    async breed() {
        // crossover and mutate
        let newPop = [];
        // lets the best solution fall through
        if (this.options.fittestNSurvives) {
            const cutted = this.cutPopulation(this.options.fittestNSurvives);

            for (const item of cutted) {
                const tempItem = JSON.parse(JSON.stringify(item));
                newPop.push({ ...tempItem });
                // newPop.push({ ...item });
            }
        }
        // Lenght may be change dynamically, because fittest and some pairs from crossover
        while (newPop.length < this.options.populationSize) {
            const crossed = await this.tryCrossover();
            newPop.push(...crossed.map((entity) => ({ fitness: null, entity, state: {} })));
        }
        if (this.options.deduplicate) {
            newPop = newPop.filter((ph) => this.options.deduplicate(ph.entity));
        }
        await this.fill(newPop);
        // console.log('newPop', newPop);
        this.population = newPop;
    }
    /**
     * Estimate population before breeding
     */
    async estimate() {
        const { fitnessFunction } = this.options;
        // reset for each generation
        this.internalGenState = {};
        let i = 0;
        for await (const target of this.population) {
            if (i > this.options.fittestNSurvives - 1 || this.population.length > 2000) {
                const { fitness, state } = await fitnessFunction(target.entity);
                target.fitness = fitness;
                target.state = state;
            }

            i++;
        }
    }
    /**
     * witre non duplicate population to csv
    */
    writeToCSV(csvFile, population, i) {
        appendFileSync(csvFile, `round${i}\n`);

        if (i !== 0) {
            population = population.slice(this.options.fittestNSurvives - 1, population.length);
        }

        for (const item of population) {
            appendFileSync(csvFile, `${item.fitness}, ${item.entity}\n`);
        }
    }
    /**
     * Appli population sorting
     */
    reorderPopulation() {
        this.population = this.population.sort((a, b) => (this.options.optimize(a, b) ? -1 : 1));
    }
    /** Fill population if is not full */
    async fill(arr) {
        while (arr.length < this.options.populationSize) {
            const entity = await this.options.randomFunction();
            arr.push({ entity, fitness: null, state: {} });
        }
    }
    /**
     * Mean deviation
     */
    getMean() {
        return this.population.reduce((a, b) => a + b.fitness, 0) / this.population.length;
    }
    /**
     * Standart deviation
     */
    getStdev(mean) {
        const { population: pop } = this;
        const l = pop.length;
        return Math.sqrt(pop.map(({ fitness }) => (fitness - mean) * (fitness - mean)).reduce((a, b) => a + b, 0) / l);
    }
    /**
     * Select one phenotype from population
     */
    selectOne() {
        const { select1 } = this.options;
        return [select1.call(this, this.population)];
    }
    /**
     * Select two phenotypes from population for crossover
     */
    selectPair() {
        const { select2 } = this.options;
        return [select2.call(this, this.population), select2.call(this, this.population)];
    }
    /**
     * Return population without an estimate (fitness)
     */
    cutPopulation(count) {
        return this.population.slice(0, count).map((ph) => ({ fitness: ph.fitness, entity: ph.entity, state: ph.state }));
    }
}
/** Utility */
function Tournament2(pop) {
    const n = pop.length;
    const a = pop[Math.floor(Math.random() * n)];
    const b = pop[Math.floor(Math.random() * n)];
    return this.options.optimize(a, b) ? a.entity : b.entity;
}
function Tournament3(pop) {
    const n = pop.length;
    const a = pop[Math.floor(Math.random() * n)];
    const b = pop[Math.floor(Math.random() * n)];
    const c = pop[Math.floor(Math.random() * n)];
    let best = this.options.optimize(a, b) ? a : b;
    best = this.options.optimize(best, c) ? best : c;
    return best.entity;
}
function Fittest$1(pop) {
    return pop[0].entity;
}
function FittestLinear$1(pop) {
    this.internalGenState['flr'] = this.internalGenState['flr'] >= pop.length ? 0 : this.internalGenState['flr'] || 0;
    return pop[this.internalGenState['flr']++].entity;
}
function FittestRandom$1(pop) {
    return pop[Math.floor(Math.random() * pop.length * 0.2)].entity;
}
function Random$1(pop) {
    return pop[Math.floor(Math.random() * pop.length)].entity;
}
function RandomLinearRank$1(pop) {
    this.internalGenState['rlr'] = this.internalGenState['rlr'] >= pop.length ? 0 : this.internalGenState['rlr'] || 0;
    return pop[Math.floor(Math.random() * Math.min(pop.length, this.internalGenState['rlr']++))].entity;
}
function Sequential$1(pop) {
    this.internalGenState['seq'] = this.internalGenState['seq'] >= pop.length ? 0 : this.internalGenState['seq'] || 0;
    return pop[this.internalGenState['seq']++ % pop.length].entity;
}
function RouletteWheel(pop) {
    const n = pop.length;
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += pop[i].fitness;
    }
    let r = Math.random() * sum;
    let i = 0;
    while (r > 0 && i < n) {
        r -= pop[i++].fitness;
    }

    return pop[i - 1].entity;
}
function Rank(pop) {
    const n = pop.length;
    const sum = (n * (n + 1)) / 2;
    let i = 0;
    let r = Math.random() * sum;
    while (r > 0 && i < n) {
        r -= ++i;
    }
    return pop[i - 1].entity;
}

exports.Genetic = Genetic;
exports.Select = Select;
